/*
 * Copyright 2009 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * GreyWolf修改移植为DexClassLoader 安卓不支持URLClassLoader  2016.5.6
 */

package com.google.devtools.simple.compiler;

import android.content.Context;

import com.google.devtools.simple.compiler.expressions.ConstantBooleanExpression;
import com.google.devtools.simple.compiler.expressions.ConstantExpression;
import com.google.devtools.simple.compiler.expressions.ConstantNumberExpression;
import com.google.devtools.simple.compiler.expressions.ConstantStringExpression;
import com.google.devtools.simple.compiler.scanner.Scanner;
import com.google.devtools.simple.compiler.scopes.GlobalScope;
import com.google.devtools.simple.compiler.scopes.ObjectScope;
import com.google.devtools.simple.compiler.symbols.AliasSymbol;
import com.google.devtools.simple.compiler.symbols.ConstantDataMemberSymbol;
import com.google.devtools.simple.compiler.symbols.DataMemberSymbol;
import com.google.devtools.simple.compiler.symbols.EventSymbol;
import com.google.devtools.simple.compiler.symbols.FunctionSymbol;
import com.google.devtools.simple.compiler.symbols.InstanceDataMemberSymbol;
import com.google.devtools.simple.compiler.symbols.InstanceFunctionSymbol;
import com.google.devtools.simple.compiler.symbols.ObjectDataMemberSymbol;
import com.google.devtools.simple.compiler.symbols.ObjectFunctionSymbol;
import com.google.devtools.simple.compiler.symbols.ObjectSymbol;
import com.google.devtools.simple.compiler.symbols.PropertySymbol;
import com.google.devtools.simple.compiler.symbols.Symbol;
import com.google.devtools.simple.compiler.types.ArrayType;
import com.google.devtools.simple.compiler.types.BooleanType;
import com.google.devtools.simple.compiler.types.ByteType;
import com.google.devtools.simple.compiler.types.DateType;
import com.google.devtools.simple.compiler.types.DoubleType;
import com.google.devtools.simple.compiler.types.IntegerType;
import com.google.devtools.simple.compiler.types.LongType;
import com.google.devtools.simple.compiler.types.ObjectType;
import com.google.devtools.simple.compiler.types.ShortType;
import com.google.devtools.simple.compiler.types.SingleType;
import com.google.devtools.simple.compiler.types.StringType;
import com.google.devtools.simple.compiler.types.Type;
import com.google.devtools.simple.compiler.types.VariantType;
import com.google.devtools.simple.util.Preconditions;
import com.wolf.util.Utils;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import java.util.logging.Level;
import java.util.logging.Logger;

import dalvik.system.DexClassLoader;

/**
 * This class loads and analyzes the Simple runtime library creating the
 * necessary symbols for the compilation process.
 * <p/>
 * <p>Simple classfiles contain annotations marking information visible
 * to the Simple compiler. Classfiles generated by the Simple compiler
 * will add this information automatically. Classfiles generated from
 * Java source code (like the Simple runtime library) need to have the
 * annotations added manually. Otherwise the Simple compiler will not
 * pick up any symbols from the class file.
 *
 * @author Herbert Czymontek
 */
public final class RuntimeLoader {
    /******
     * 修改为DexClassLoader
     ********/

    DexClassLoader dexClassLoader = null;
//    ArrayList<String> xclassnames = null;

    /******
     * 修改为DexClassLoader
     ********/

//    /*
//     * Special class loader for loading Simple runtime library classes.
//     * Needed for injection of a new classpath into a running compiler.
//     */
//    private static class RuntimeClassLoader extends URLClassLoader {
//
//        public RuntimeClassLoader(URL[] urls, ClassLoader parent) {
//            super(urls, parent);
//        }
//
//        @Override
//        public Class<?> loadClass(String name) throws ClassNotFoundException {
//            try {
//                return findClass(name);
//            } catch (Exception e) {
//                return super.loadClass(name);
//            }
//        }
//    }

    // Logging support
    private static final Logger LOG = Logger.getLogger(RuntimeLoader.class.getName());

    // Classfile extension
    private static final String CLASSFILE_EXTENSION = ".class";

    // Package where Simple annotations live
    public static final String ANNOTATION_PACKAGE = Compiler.RUNTIME_ROOT_PACKAGE + ".annotations";
    public static final String ANNOTATION_INTERNAL = ANNOTATION_PACKAGE.replace('.', '/');

    // Reference parameter runtime class names
    private static final String REFERENCE_PARAMETER_PACKAGE =
            Compiler.RUNTIME_ROOT_PACKAGE + ".parameters";

    private static final String BOOLEAN_REFERENCE_PARAMETER_NAME =
            REFERENCE_PARAMETER_PACKAGE + ".BooleanReferenceParameter";
    private static final String BYTE_REFERENCE_PARAMETER_NAME =
            REFERENCE_PARAMETER_PACKAGE + ".ByteReferenceParameter";
    private static final String DATE_REFERENCE_PARAMETER_NAME =
            REFERENCE_PARAMETER_PACKAGE + ".DateReferenceParameter";
    private static final String DOUBLE_REFERENCE_PARAMETER_NAME =
            REFERENCE_PARAMETER_PACKAGE + ".DoubleReferenceParameter";
    private static final String INTEGER_REFERENCE_PARAMETER_NAME =
            REFERENCE_PARAMETER_PACKAGE + ".IntegerReferenceParameter";
    private static final String LONG_REFERENCE_PARAMETER_NAME =
            REFERENCE_PARAMETER_PACKAGE + ".LongReferenceParameter";
    private static final String OBJECT_REFERENCE_PARAMETER_NAME =
            REFERENCE_PARAMETER_PACKAGE + ".ObjectReferenceParameter";
    private static final String SHORT_REFERENCE_PARAMETER_NAME =
            REFERENCE_PARAMETER_PACKAGE + ".ShortReferenceParameter";
    private static final String SINGLE_REFERENCE_PARAMETER_NAME =
            REFERENCE_PARAMETER_PACKAGE + ".SingleReferenceParameter";
    private static final String STRING_REFERENCE_PARAMETER_NAME =
            REFERENCE_PARAMETER_PACKAGE + ".StringReferenceParameter";
    private static final String VARIANT_REFERENCE_PARAMETER_NAME =
            REFERENCE_PARAMETER_PACKAGE + ".VariantReferenceParameter";

    // Classloader to load Simple runtime library classes
//    private RuntimeClassLoader runtimeClassLoader;

    // Root directory of runtime library
    private final File runtimeRoot;

    // Simple compiler instance
    private final Compiler compiler;

    // Simple class file annotations
    private Class<? extends Annotation> simpleComponent;
    private Class<? extends Annotation> simpleObject;
    private Class<? extends Annotation> simpleDataElement;
    private Class<? extends Annotation> simpleEvent;
    private Class<? extends Annotation> simpleFunction;
    private Class<? extends Annotation> simpleProperty;
    private Class<? extends Annotation> androidUsesPermission;

    private Class<?> simpleReferenceParameter;

    // For mapping components to their implementors
    private List<Class<?>> classList;
    private Map<Class<?>, ObjectSymbol> classMap;
    private Map<ObjectSymbol, String> componentMap;

    /*
     * Loads a Simple class file annotation.
     * 修改dexclassloader
     */
    @SuppressWarnings("unchecked")
    private Class<? extends Annotation> loadAnnotationClass(String name) {
//         (Class<? extends Annotation>) Class.forName(ANNOTATION_PACKAGE + '.' + name, false,
//                runtimeClassLoader);
        //不用加载android.jar
        try {
            //尝试直接找到class  android.jar内
            return (Class<? extends Annotation>) Class.forName(ANNOTATION_PACKAGE + '.' + name);
        } catch (ClassNotFoundException e) {
            try {
                //从xruntime.jar中加载
                return (Class<? extends Annotation>) dexClassLoader.loadClass(ANNOTATION_PACKAGE + '.' + name);
            } catch (ClassNotFoundException e1) {
                e1.printStackTrace();
                LOG.log(Level.SEVERE, "Runtime library load failure", e);
                compiler.error(Scanner.NO_POSITION, Error.errReadError, "xruntime.jar");
            }
        }
        Utils.log("未能成功加载类1");
        return null;
    }

    /**
     * 加载类
     *
     * @param name
     * @return
     */
    private Class<?> loadXClass(String name) {
//         (Class<? extends Annotation>) Class.forName(ANNOTATION_PACKAGE + '.' + name, false,
//                runtimeClassLoader);
        //不用加载android.jar
        try {
            //尝试直接找到class  android.jar内
            return (Class<?>) Class.forName(name);
        } catch (ClassNotFoundException e) {
            try {
                //从xruntime.jar中加载
                return (Class<?>) dexClassLoader.loadClass(name);
            } catch (ClassNotFoundException e1) {
                e1.printStackTrace();
                Main.state(e1.toString());
            }
        }
        Utils.log("未能成功加载类2");
        return null;
    }

    /**
     * Get the UsesPermission attribute for this class loader
     *
     * @return {@code UsesPermissions} class from runtime library
     */
    public Class<? extends Annotation> getAndroidUsesPermission() {
        return androidUsesPermission;
    }

    /**
     * Creates a new Simple runtime loader.
     *
     * @param compiler      Simple compiler instance
     * @param simpleRuntime path to Simple runtime library
     *                      <p/>
     *                      <p>Note: The reason we need the platform runtime library (Android or
     *                      whatever) is because the Simple runtime library depends on it and
     *                      therefore not having it would result in ClassNotFoundExceptions when
     *                      loading Simple classes from its runtime library.
     *                      <p/>
     *                      android.jar   simpleruntime.jar
     */
    public RuntimeLoader(Compiler compiler, String simpleRuntime, Context context) {
        this.compiler = compiler;
//        this.xclassnames = new ArrayList<String>();

        // Instantiate classfile loader for Simple runtime library
//        try {
//            runtimeClassLoader = new RuntimeClassLoader(new URL[]{
//                    new File(simpleRuntime).toURI().toURL(), new File(platformRuntime).toURI().toURL()},
//                    getClass().getClassLoader());
//        } catch (MalformedURLException mue) {
//            // Cannot happen
//        }
        /***
         * Parameters
         dexPath	需要装载的APK或者Jar文件的路径。包含多个路径用File.pathSeparator间隔开,在Android上默认是 ":"
         optimizedDirectory	优化后的dex文件存放目录，不能为null
         libraryPath	目标类中使用的C/C++库的列表,每个目录用File.pathSeparator间隔开; 可以为 null
         parent	该类装载器的父装载器，一般用当前执行类的装载器*/
        //初始化dexclassloader
        dexClassLoader = new DexClassLoader(simpleRuntime, context.getDir("runtimedex", Context.MODE_PRIVATE).getAbsolutePath(), null, getClass().getClassLoader());

        componentMap = new HashMap<ObjectSymbol, String>();
        runtimeRoot = new File(simpleRuntime);

        try {
            // Load Simple classfile annotations
            simpleComponent = loadAnnotationClass("SimpleComponent");
            simpleObject = loadAnnotationClass("SimpleObject");
            simpleDataElement = loadAnnotationClass("SimpleDataElement");
            simpleEvent = loadAnnotationClass("SimpleEvent");
            simpleFunction = loadAnnotationClass("SimpleFunction");
            simpleProperty = loadAnnotationClass("SimpleProperty");
            androidUsesPermission = loadAnnotationClass("UsesPermissions");

            // Load Simple reference parameter superclass
            simpleReferenceParameter = dexClassLoader.loadClass(com.google.devtools.simple.compiler.Compiler.RUNTIME_ROOT_PACKAGE +
                    ".parameters.ReferenceParameter");

        } catch (ClassNotFoundException e) {
            LOG.log(Level.SEVERE, "Runtime library load failure", e);
            compiler.error(Scanner.NO_POSITION, Error.errReadError, simpleRuntime);
        }
        if (simpleComponent == null || simpleObject == null || simpleDataElement == null || simpleEvent == null || simpleFunction == null ||
                simpleProperty == null || androidUsesPermission == null || simpleReferenceParameter == null) {
            Utils.log("有类为NULL");
            Main.state("load xruntime faile NULL");
        }
    }

    /*
     * Converts a class to its corresponding Simple type.
     */
    private Type convertToSimpleType(Class<?> cls) {
        if (cls.equals(Boolean.TYPE)) {
            return BooleanType.booleanType;
        } else if (cls.equals(Byte.TYPE)) {
            return ByteType.byteType;
        } else if (cls.equals(Short.TYPE)) {
            return ShortType.shortType;
        } else if (cls.equals(Integer.TYPE)) {
            return IntegerType.integerType;
        } else if (cls.equals(Long.TYPE)) {
            return LongType.longType;
        } else if (cls.equals(Float.TYPE)) {
            return SingleType.singleType;
        } else if (cls.equals(Double.TYPE)) {
            return DoubleType.doubleType;
        } else if (cls.equals(Void.TYPE)) {
            return null;
        } else if (cls.equals(String.class)) {
            return StringType.stringType;
        } else if (cls.equals(GregorianCalendar.class)) {
            return DateType.dateType;
        } else if (cls.getName().equals(VariantType.VARIANT_NAME)) {
            return VariantType.variantType;
        } else if (cls.isArray()) {
            int dimensions = 1;
            cls = cls.getComponentType();
            while (cls.isArray()) {
                dimensions++;
                cls = cls.getComponentType();
            }
            return new ArrayType(convertToSimpleType(cls), dimensions);
        } else if (isSimpleReferenceParameter(cls)) {
            String className = cls.getName();
            if (className.equals(BOOLEAN_REFERENCE_PARAMETER_NAME)) {
                return BooleanType.booleanType;
            } else if (className.equals(BYTE_REFERENCE_PARAMETER_NAME)) {
                return ByteType.byteType;
            } else if (className.equals(DATE_REFERENCE_PARAMETER_NAME)) {
                return DateType.dateType;
            } else if (className.equals(DOUBLE_REFERENCE_PARAMETER_NAME)) {
                return DoubleType.doubleType;
            } else if (className.equals(INTEGER_REFERENCE_PARAMETER_NAME)) {
                return IntegerType.integerType;
            } else if (className.equals(LONG_REFERENCE_PARAMETER_NAME)) {
                return LongType.longType;
            } else if (className.equals(SINGLE_REFERENCE_PARAMETER_NAME)) {
                return SingleType.singleType;
            } else if (className.equals(SHORT_REFERENCE_PARAMETER_NAME)) {
                return ShortType.shortType;
            } else if (className.equals(STRING_REFERENCE_PARAMETER_NAME)) {
                return StringType.stringType;
            } else if (className.equals(VARIANT_REFERENCE_PARAMETER_NAME)) {
                return VariantType.variantType;
            } else {
                Preconditions.checkState(className.equals(OBJECT_REFERENCE_PARAMETER_NAME));
                return ObjectType.objectType;
            }
        } else {
            ObjectSymbol objectSymbol =
                    ObjectSymbol.getObjectSymbol(compiler, cls.getName().replace('.', '/'));
            return objectSymbol.getType();
        }
    }

    /*
     * Get constant value.
     */
    private ConstantExpression getConstantExpression(Field f) {
        Class<?> cls = f.getType();
        try {
            if (cls.equals(Boolean.TYPE)) {
                return new ConstantBooleanExpression(Scanner.NO_POSITION, f.getBoolean(null));
            } else if (cls.equals(Byte.TYPE)) {
                return new ConstantNumberExpression(Scanner.NO_POSITION, new BigDecimal(f.getByte(null)));
            } else if (cls.equals(Short.TYPE)) {
                return new ConstantNumberExpression(Scanner.NO_POSITION, new BigDecimal(f.getShort(null)));
            } else if (cls.equals(Integer.TYPE)) {
                return new ConstantNumberExpression(Scanner.NO_POSITION, new BigDecimal(f.getInt(null)));
            } else if (cls.equals(Long.TYPE)) {
                return new ConstantNumberExpression(Scanner.NO_POSITION, new BigDecimal(f.getLong(null)));
            } else if (cls.equals(Float.TYPE)) {
                return new ConstantNumberExpression(Scanner.NO_POSITION, new BigDecimal(f.getFloat(null)));
            } else if (cls.equals(Double.TYPE)) {
                return new ConstantNumberExpression(Scanner.NO_POSITION, new BigDecimal(f.getDouble(null)));
            } else if (cls.equals(String.class)) {
                return new ConstantStringExpression(Scanner.NO_POSITION, (String) f.get(null));
            } else {
                return null;
            }
        } catch (IllegalAccessException ignored) {
            // This should never happen
            return null;
        }
    }

    /*
     * Checks whether a class represents a reference parameter.
     */
    private boolean isSimpleReferenceParameter(Class<?> cls) {
        Class<?> supercls = cls.getSuperclass();
        return supercls != null && supercls.equals(simpleReferenceParameter);
    }

    /*
     * Analyzes a classfile for Simple information.
     */
    private void analyzeClassFile(String className) {
        try {
            // Skip classfiles from the annotation package (they don't contain any runtime
            // functionality and are for marking exclusively)
            if (!className.startsWith(ANNOTATION_PACKAGE)) {
                Class<?> cls = loadXClass(className);
                classList.add(cls);

                // Only interested in classes marked as SimpleObjects
                if (cls.isAnnotationPresent(simpleObject)) {
                    String internalClassName = cls.getName().replace('.', '/');

                    // Add a symbol for the object to the compilers symbol tables
                    ObjectSymbol objectSymbol = ObjectSymbol.getObjectSymbol(compiler, internalClassName);

                    // Base objects of Simple objects need to be other Simple Objects or java.lang.Object
                    Class<?> superclass = cls.getSuperclass();
                    if (superclass != null && !superclass.equals(Object.class)) {
                        objectSymbol.setBaseObject((ObjectType) ObjectSymbol.getObjectSymbol(compiler,
                                superclass.getCanonicalName().replace('.', '/')).getType());
                    }

                    // Objects from the package 'com.google.devtools.simple.runtime' and its sub-packages
                    // automatically receive an alias entry in the global namespace.
                    GlobalScope globalScope = (GlobalScope) compiler.getGlobalNamespaceSymbol().getScope();
                    String packageName = cls.getPackage().getName();
                    if (packageName.startsWith(com.google.devtools.simple.compiler.Compiler.RUNTIME_ROOT_PACKAGE)) {
                        globalScope.enterSymbol(new AliasSymbol(Scanner.NO_POSITION, objectSymbol.getName(),
                                objectSymbol));
                        LOG.log(Level.FINEST, "Loading runtime: global alias for object " +
                                objectSymbol.getName());
                    }

                    // Check for interface objects
                    if (cls.isInterface()) {
                        objectSymbol.markAsInterface();
                    }

                    // Is this a component? Remember it - on a second pass we will attempt to find its
                    // implementor
                    if (cls.isAnnotationPresent(simpleComponent)) {
                        classMap.put(cls, objectSymbol);
                    }

                    // Next check all methods defined in the class file
                    for (Method m : cls.getMethods()) {
                        if (m.isAnnotationPresent(simpleProperty)) {
                            // This method is either a property getter or property setter
                            String propertyName = m.getName();

                            // Figure out the property type
                            Type type;
                            Class<?> returnType = m.getReturnType();
                            if (returnType.equals(Void.TYPE)) {
                                // This is a property setter and can have at most one parameter (which is the
                                // new property value).
                                Class<?> params[] = m.getParameterTypes();
                                if (params.length != 1) {
                                    com.google.devtools.simple.compiler.Compiler.internalError();  // COV_NF_LINE
                                }
                                type = convertToSimpleType(params[0]);
                            } else {
                                type = convertToSimpleType(returnType);
                            }

                            // Add a new symbol for the property to the object's symbol tables. Since the
                            // property is split up into getter and setter and we can't track which one we
                            // have already seen, we need to check whether there is already a property symbol
                            // defined.
                            ObjectScope classScope = objectSymbol.getScope();
                            Symbol symbol = classScope.lookupInObject(propertyName);
                            if (symbol == null) {
                                objectSymbol.addProperty(new PropertySymbol(Scanner.NO_POSITION, objectSymbol,
                                        propertyName, type), null, null);
                            }
                        } else if (m.isAnnotationPresent(simpleFunction)) {
                            // This method is a Simple function (or procedure)
                            FunctionSymbol function = ((m.getModifiers() & Modifier.STATIC) != 0) ?
                                    new ObjectFunctionSymbol(Scanner.NO_POSITION, objectSymbol, m.getName()) :
                                    new InstanceFunctionSymbol(Scanner.NO_POSITION, objectSymbol, m.getName());
                            function.setResultType(convertToSimpleType(m.getReturnType()));

                            // Analyze its result and parameter types
                            for (Class<?> argClass : m.getParameterTypes()) {
                                function.addParameter(Scanner.NO_POSITION, null, convertToSimpleType(argClass),
                                        isSimpleReferenceParameter(argClass));
                            }

                            // Add symbol for the function to the object's symbol tables
                            objectSymbol.addFunction(function);

                            // Static functions from objects from the package 'com.google.devtools.simple.runtime'
                            // automatically receive an alias entry in the global namespace.
                            if (function instanceof ObjectFunctionSymbol &&
                                    packageName.equals(com.google.devtools.simple.compiler.Compiler.RUNTIME_ROOT_PACKAGE)) {
                                globalScope.enterSymbol(new AliasSymbol(Scanner.NO_POSITION, function.getName(),
                                        function));
                                LOG.log(Level.FINEST, "Loading runtime: global alias for function " +
                                        objectSymbol.getName());
                            }

                        } else if (m.isAnnotationPresent(simpleEvent)) {
                            // This method is a Simple event definition
                            EventSymbol event = new EventSymbol(Scanner.NO_POSITION, objectSymbol, m.getName());
                            // Analyze its result and parameter types
                            for (Class<?> argClass : m.getParameterTypes()) {
                                event.addParameter(Scanner.NO_POSITION, null, convertToSimpleType(argClass),
                                        isSimpleReferenceParameter(argClass));
                            }

                            // Add symbol for the function to the object's symbol tables
                            objectSymbol.addEvent(event);
                        }
                    }

                    // Next check all fields defined in the class file
                    for (Field f : cls.getFields()) {
                        if (f.isAnnotationPresent(simpleDataElement)) {
                            // This field is a Simple data element
                            String name = f.getName();
                            Type type = convertToSimpleType(f.getType());

                            DataMemberSymbol dataMember;
                            if ((f.getModifiers() & Modifier.STATIC) != 0) {

                                ConstantExpression constExpr = null;
                                if ((f.getModifiers() & Modifier.FINAL) != 0) {
                                    constExpr = getConstantExpression(f);
                                }

                                if (constExpr != null) {
                                    dataMember = new ConstantDataMemberSymbol(Scanner.NO_POSITION, objectSymbol, name,
                                            type, constExpr);
                                } else {
                                    dataMember = new ObjectDataMemberSymbol(Scanner.NO_POSITION, objectSymbol, name,
                                            type);
                                }
                            } else {
                                dataMember = new InstanceDataMemberSymbol(Scanner.NO_POSITION, objectSymbol, name,
                                        type);
                            }

                            // Add symbol for the data member to the object's symbol tables
                            objectSymbol.addDataMember(dataMember);

                            // Static data members from objects from the package
                            // 'com.google.devtools.simple.runtime' automatically receive an alias entry in the
                            // global namespace.
                            if (dataMember instanceof ObjectDataMemberSymbol &&
                                    packageName.equals(com.google.devtools.simple.compiler.Compiler.RUNTIME_ROOT_PACKAGE)) {
                                globalScope.enterSymbol(new AliasSymbol(Scanner.NO_POSITION, dataMember.getName(),
                                        dataMember));
                                LOG.log(Level.FINEST, "Loading runtime: global alias for data member " +
                                        objectSymbol.getName());
                            }
                        }
                    }
                    // TODO: this is in the wrong place.  We're loading all the runtime library classes here,
                    //       not just the ones used by our app. We really only care about the one's used by
                    //       the app that we're compiling
                    if (cls.isAnnotationPresent(androidUsesPermission)) {
                        compiler.addToPermissions(cls, objectSymbol);
                    }
                }
            }
        } catch (Exception e) {
            LOG.log(Level.SEVERE, "Runtime library load failure", e);
            compiler.error(Scanner.NO_POSITION, Error.errReadError, className);
        }
    }

    /*
     * Recursively visits all directories under the runtime root directory and loads and analyzes
     * any Simple classes found.
     */
    private void visitClassDirectories(File file) {
        if (file.isDirectory()) {
            // Recursively visit directories
            for (String child : file.list()) {
                visitClassDirectories(new File(file, child));
            }
        } else if (file.getName().endsWith(".jar")) {
            // Handle Jar libraries
            try {
                JarFile jar = new JarFile(file, false, JarFile.OPEN_READ);
                Enumeration<JarEntry> jarEntries = jar.entries();
                while (jarEntries.hasMoreElements()) {
                    JarEntry entry = jarEntries.nextElement();
                    String name = entry.getName();
                    if (name.endsWith(Compiler.ORIGINAL)) {
                        InputStream in = jar.getInputStream(entry);
                        ByteArrayOutputStream out = new ByteArrayOutputStream(in.available());
                        byte[] b = new byte[1024 * 8];
                        int n;
                        while ((n = in.read(b)) != -1) {
                            out.write(b, 0, n);
                        }
                        in.close();
                        out.flush();
                        out.close();
                        String[] ns = out.toString().split("#");
                        Utils.log("xruntime.jar加载到的类个数=" + ns.length);
                        for (String str : ns) {
                            if (str != null && (!str.equals(""))) {
                                analyzeClassFile(str);
                            }
                        }
                        return;
                    }

//                    if (name.endsWith(CLASSFILE_EXTENSION)) {
//                        // On Windows platform (and probably always) JarEntry.getName() uses '/' as separator
//                        String CN = name.substring(0, name.length() - CLASSFILE_EXTENSION.length()).replace('/', '.');
//                        xclassnames.add(CN);
//
//                        analyzeClassFile(CN);
//                    }
                }
            } catch (IOException ioe) {
                LOG.log(Level.SEVERE, "Runtime library load failure", ioe);
                compiler.error(Scanner.NO_POSITION, Error.errReadError, file.getName());
            } catch (SecurityException ignored) {
                // This should never happen. If it does anyway the bucket exception handler will pick it up.
                throw ignored;
            }
        } else {
            String name = file.getName();
            if (name.endsWith(CLASSFILE_EXTENSION)) {
                // Class file
                String path = file.getAbsolutePath();
                analyzeClassFile(path.substring(runtimeRoot.getAbsolutePath().length() + 1,
                        path.length() - CLASSFILE_EXTENSION.length()).replace(File.separatorChar, '.'));
            }
        }
    }

    /*
     * Maps components to their actual implementations
     * 组件映射到实际实现
     */
    private void findComponentImplementations() {
        for (Class<?> cls : classList) {
            for (Class<?> iface : cls.getInterfaces()) {
                if (checkComponentImplementation(cls, iface)) {
                    break;
                }
            }
            checkComponentImplementation(cls, cls.getSuperclass());
        }

        // If there is any component implementations missing, error will be reported
        for (ObjectSymbol component : classMap.values()) {
            compiler.error(Scanner.NO_POSITION, Error.errNoComponentImplementation,
                    component.getType().toString());
        }
    }

    private boolean checkComponentImplementation(Class<?> cls, Class<?> implementor) {
        ObjectSymbol component = classMap.get(implementor);
        if (component != null) {
            componentMap.put(component, cls.getName().replace('.', '/'));
            classMap.remove(implementor);
            return true;
        }

        return false;
    }

    /**
     * Returns the internal name of the implementation for the given component
     * object type.
     *
     * @param type component object type
     * @return internal name of component object
     */
    String getComponentImplementationInternalName(ObjectType type) {
        return componentMap.get(type.getObjectSymbol());
    }

    /**
     * Loads and analyzes classes in the Simple runtime library and enters there symbol information
     * into the compilers symbol tables.
     * 仅仅从原始Jar中获取所有类名
     * 从xruntime.jar加载类
     */
    public void loadSimpleObjects() {
        // Load all Simple objects
        //加载所有Simple的对象
        classList = new ArrayList<Class<?>>();
        classMap = new HashMap<Class<?>, ObjectSymbol>();
        visitClassDirectories(runtimeRoot);
        //157个
        /***/
       /* try {
            BufferedWriter out = new BufferedWriter(new FileWriter(new File(Environment.getExternalStorageDirectory().getAbsolutePath() + "/aaaa.txt")));
            for (String s : xclassnames) {
                out.write(s + "#");
            }
            out.close();
            Log.i("xwolf", "size=" + xclassnames.size());
        } catch (IOException e) {
            e.printStackTrace();
        }*/
        /***/

        // Find Simple component implementations
        //找到Simple的组件实现
        findComponentImplementations();
        classList = null;
        classMap = null;
    }
}
